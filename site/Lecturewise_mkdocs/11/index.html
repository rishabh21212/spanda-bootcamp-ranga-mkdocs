
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../10/">
      
      
        <link rel="next" href="../12/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.7">
    
    
      
        <title>11 - Spanda DL Bootcamp</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.f2e4d321.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="purple">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Spanda DL Bootcamp" class="md-header__button md-logo" aria-label="Spanda DL Bootcamp" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Spanda DL Bootcamp
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              11
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="teal" data-md-color-accent="purple"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="teal" data-md-color-accent="lime"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-hidden="true"  type="radio" name="__palette" id="__palette_2">
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
    
  
  The Complete Generative AI Bootcamp

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../01/" class="md-tabs__link">
          
  
  Lecturewise mkdocs

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Spanda DL Bootcamp" class="md-nav__button md-logo" aria-label="Spanda DL Bootcamp" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Spanda DL Bootcamp
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    The Complete Generative AI Bootcamp
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    Lecturewise mkdocs
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Lecturewise mkdocs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../01/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    01
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../02/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    02
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../03/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    03
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../04/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    04
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../05/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    05
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../06.5/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    06.5
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../06/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    06
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../07/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    07
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../08/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    08
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../09/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    09
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../10/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    10
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    11
  </span>
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../12/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    12
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../13/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    13
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../14/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    14
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../15/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    15
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../16/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    16
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../17/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    17
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../18/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    18
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../19/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    LLM's & NLP Introduction
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../20/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Retrieval Augmented Generation (RAG)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../21/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RAG Pipeline Implementation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../22/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    From Simple to Advanced RAG
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../23/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Observability Tools for RAG
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>11</h1>

<p><strong>Federated Learning</strong></p>
<p>What Is Federated Learning?</p>
<ul>
<li>
<p>This section frames <strong>federated learning</strong> (<strong>FL</strong>) as the answer to
    the desire for this new ML approach.</p>
</li>
<li>
<p>In a nutshell, FL is an approach to ML that allows models to be
    trained in parallel across data sources without the transmission of
    any data.</p>
</li>
<li>
<p>The goal of This section is to build up the case for the FL
    approach, with explanations of the necessary conceptual building
    blocks in order to ensure that you can achieve a similar
    understanding of the technical aspects and practical usage of FL.</p>
</li>
<li>
<p>After going through this section, you should have a high-level
    understanding of the FL process and should be able to visualize
    where the approach slots into real-world problem domains.</p>
</li>
</ul>
<p>Topics covered:</p>
<ul>
<li>
<p>Understanding the current state of ML</p>
</li>
<li>
<p>Distributed learning nature -- toward scalable AI</p>
</li>
<li>
<p>Understanding FL</p>
</li>
<li>
<p>FL system considerations</p>
</li>
</ul>
<p>ML - Current State</p>
<ul>
<li>To understand why the benefits derived from the application of FL
    can outweigh the increased complexity of this approach, it is
    necessary to understand how ML is currently practiced and the
    associated limitations. The goal of this section is to provide you
    with this context.</li>
</ul>
<p>The Model</p>
<ul>
<li>
<p>The term "model" finds usage across numerous different disciplines;
    however, the generalized definition we are interested in can be
    narrowed down to a working representation of the dynamics within
    some desired system.</p>
</li>
<li>
<p>Simply put, we develop a model B of some phenomenon A as a means of
    better understanding A through the increased interaction offered by
    B.</p>
</li>
<li>
<p>Consider the phenomenon of an object being dropped from some point
    in a vacuum.</p>
</li>
<li>
<p>Using kinematic equations, we can compute exactly how long it will
    take for the object to hit the ground -- this is a model of the
    aforementioned phenomenon.</p>
</li>
<li>
<p>The power of this approach is the ability to observe results from
    the created model without having to explicitly interact with the
    phenomenon in question.</p>
</li>
<li>
<p>For example, the model of the falling object allows us to determine
    the difference in fall time between a 10 kg object and a 50 kg
    object at some height without having to physically drop real objects
    from said height in a real vacuum.</p>
</li>
<li>
<p>Evidently, the modeling of natural phenomena plays a key role in
    being able to claim a true understanding of said phenomena.</p>
</li>
<li>
<p>Removing the need for the comprehensive observation of a phenomenon
    allows for true generalization in the decision-making process.</p>
</li>
<li>
<p>The concept of a model is greatly narrowed down within the context
    of computer science. In this context, models are algorithms that
    allow for some key values of a phenomenon to be output given some
    initial characterization of the phenomenon in question.</p>
</li>
<li>
<p>Going back to the falling object example, a computer science model
    could entail the computation of values such as the time to hit the
    ground and the maximum speed given the mass of the object and the
    height from which it is dropped.</p>
</li>
<li>
<p>These computer science models are uniquely powerful due to the
    superhuman ability of computers to compute the output from countless
    starting phenomenon configurations, offering us even greater
    understanding and generalization.</p>
</li>
<li>
<p>So, how do we create such models?</p>
</li>
<li>
<p>The first and simplest approach is building rule-based systems
    or <strong>white-box</strong> models.</p>
</li>
<li>
<p>A white-box (also known as glass-box or clear-box) model is made by
    writing down the underlying functions of a system of interest
    explicitly.</p>
</li>
<li>
<p>This is only possible when information about the system is
    available <em>a priori</em>.</p>
</li>
<li>
<p>Naturally, in this case, the underlying functions are relatively
    simple.</p>
</li>
<li>
<p>One such example is the problem of classifying a randomly selected
    integer as odd or even; we can easily write an algorithm to do this
    by <em>checking the remainder after dividing the integer by two</em>.</p>
</li>
<li>
<p>If you want to see how much it costs to fill up your gas tank, given
    how empty the tank is and the price per gallon, you can just
    multiply those values together.</p>
</li>
<li>
<p>Despite their simplicity, these examples illustrate that simple
    models can have a lot of practical applications in various fields.</p>
</li>
<li>
<p>Unfortunately, the white-box modeling of underlying functions can
    quickly become too complex to perform directly. In general, systems
    are often too complex for us to be able to construct a white-box
    model for.</p>
</li>
<li>
<p>For example, let's say you want to predict the future values of your
    property.</p>
</li>
<li>
<p>You have a lot of metrics about the property, such as the area, how
    old it is, its location, and interest rate to name but a few.</p>
</li>
<li>
<p>You believe that there is likely a linear relationship between the
    property value and all of those metrics, such that the weighted sum
    of all of them would give you the property value.</p>
</li>
<li>
<p>Now, if you actually try to build a white-box model under that
    assumption, you will have to directly figure out what the parameter
    (weight) for each metric is, which implies that you must know the
    underlying function of the real estate pricing system. Usually, this
    is not the case.</p>
</li>
<li>
<p>Therefore, we need another approach: <strong>black box</strong> modeling.</p>
</li>
</ul>
<p>Automating Model Creation</p>
<ul>
<li>
<p>The concept of a black box system was first developed in the field
    of electric circuits during the WWII period.</p>
</li>
<li>
<p>It was the famous cybernetician Norbert Wiener who began treating
    the black box as an abstract concept, and a general theory was
    established by Mario Augusto Bunge in the 1960s.</p>
</li>
<li>
<p>The function for estimating future property values, as illustrated
    earlier, is a good example of a black box.</p>
</li>
<li>
<p>As you might expect, the function is complex enough that it is
    unreasonable for us to try to write a white-box model to represent
    it.</p>
</li>
<li>
<p>This is where ML comes in, allowing us to create a model as a black
    box.</p>
</li>
</ul>
<p><em>Reference</em></p>
<ul>
<li>
<p>You might be aware that black box modeling has been criticized for
    its lack of interpretability, an important concept outside the scope
    of this tutorial; <em>Interpretable Machine Learning</em> covers this area.</p>
</li>
<li>
<p>ML is a type of artificial intelligence that is used to
    automatically generate model parameters for making decisions and
    predictions. </p>
</li>
<li>
<p><em>Figure 2.1</em> illustrates this in a very simple way: those cases
    where the known values and the unknown value have a linear
    relationship allow a popular algorithm, called <strong>ordinary least
    squares</strong> (<strong>OLS</strong>), to be applied. OLS computes the unknown
    parameters of the linear relationship by finding the set of
    parameters that produces the closest predictions on some set of
    known examples (pairs of input feature value sets and the true
    output value):</p>
</li>
</ul>
<p><img alt="Figure 2.1 -- ML determining model parameters
" src="../images/media/image76.jpg" />{width="6.268055555555556in"
height="4.7034722222222225in"}</p>
<p>Figure 2.1 -- ML determining model parameters</p>
<ul>
<li>
<p>The preceding diagram displays a simple two-dimensional linear
    regression problem with one feature/input variable and one output
    variable. In this toy two-dimensional case, it might be relatively
    straightforward for us to come up with the parameters representing
    the best-fit relationship directly, either through implicit
    knowledge or through testing different values.</p>
</li>
<li>
<p>However, it should be clear that this approach quickly becomes
    intractable as the number of feature variables increases.</p>
</li>
<li>
<p>OLS allows us to attack this problem from the reverse direction:
    instead of producing linear relationships and evaluating them on the
    data, we can use the data to compute the parameters of the best-fit
    relationship directly instead.</p>
</li>
<li>
<p>Revisiting the real estate problem, let's assume that we have
    collected a large number of property valuation data points,
    consisting of the associated metric values and the sale price.</p>
</li>
<li>
<p>We can apply OLS to take these points and find the relationship
    between each metric and the sale price for any property (still under
    the assumption that the true relationship is linear).</p>
</li>
<li>
<p>From this, we can pass in the metric values of our property and get
    the predicted sale price.</p>
</li>
<li>
<p>The power of this approach is the abstraction of this relationship
    computation from any implicit knowledge of the problem.</p>
</li>
<li>
<p>The OLS algorithm doesn't care what the data represents -- it just
    finds the best line for the data it is given.</p>
</li>
<li>
<p>This class of approaches is exactly what ML entails, granting the
    power to create models of phenomena without any required knowledge
    of the internal relationship, given a sufficient amount of data.</p>
</li>
<li>
<p>In a nutshell, ML lets us program algorithms that can learn to
    create models from data, and our motivation to do so is to
    approximate complex systems.</p>
</li>
<li>
<p>It is important to keep in mind that the underlying functions of a
    complex system can change over time due to outside factors, quickly
    making models created from old data obsolete.</p>
</li>
<li>
<p>For example, the preceding linear regression model might not work to
    estimate property values in a far distant future or a faraway
    district.</p>
</li>
<li>
<p>Variance in such a macroscopic scale is not taken into account in a
    model containing only a few dozen parameters, and we would need
    different models for separate groups of adjacent data points --
    unless we employ even more sophisticated ML approaches such
    as <strong>deep learning</strong>.</p>
</li>
</ul>
<p>Deep Learning (DL)</p>
<ul>
<li>
<p>So, how did deep learning become synonymous with ML in common usage?</p>
</li>
<li>
<p>Deep learning involves the application of a <strong>deep neural
    network</strong> (<strong>DNN</strong>), which is a type of highly-parameterized model
    inspired by the transmission of signals between neurons in the
    brain.</p>
</li>
<li>
<p>The foundation of deep learning was established in the early 1960s
    by Frank Rosenblatt, who is known as the <em>father of deep learning</em>.</p>
</li>
<li>
<p>His work was further developed in the 1970s and 1980s by computer
    scientists including Geoffrey Hinton, Yann LeCun, and Yoshua Bengio,
    and the term <em>deep learning</em> was popularized by the University of
    California, Irvine's distinguished Professor Rina Dechter. Deep
    learning can conduct much more complex tasks compared to simpler ML
    algorithms such as linear regression.</p>
</li>
<li>
<p>While the specifics are beyond the scope of this book, the key
    problem that deep learning was able to solve was the <strong><em>modeling of
    complex non-linear relationships</em></strong>, pushing ML as a whole to the
    forefront of numerous fields due to the increased modeling ability
    it provided.</p>
</li>
<li>
<p>This ability has been mathematically proven via specific universal
    approximation theorems for different model size cases.</p>
</li>
<li>
<p>Over the past decade, ever-increasingly powerful models have been
    built by tech giants against the backdrop of big data.</p>
</li>
<li>
<p>If we look at the state-of-the-art deep learning models today, they
    could have up to trillions of parameters; expectedly, this gives
    them unparalleled flexibility in modeling complex functions.</p>
</li>
<li>
<p>The reason deep learning models can be scaled up to arbitrarily
    increase performance, unlike other ML model types used previously,
    is due to a phenomenon called <strong>double descent</strong>.</p>
</li>
<li>
<p>This refers to the ability for a certain parameterization/training
    threshold to overcome the standard bias-variance trade-off (where
    increasing complexity leads to fine-tuning on training data,
    reducing bias but increasing variance) and continuing to increase
    performance.</p>
</li>
<li>
<p>The key takeaway is that the performance of deep learning models can
    be considered to be limited by just the available compute power and
    data, two factors that have surged in growth in the past 10 years
    due to advances in computing and the ever-increasing number of
    devices and software collecting data, respectively.</p>
</li>
<li>
<p>Deep learning has become intertwined with ML, with deep learning
    playing a significant role within the current state of ML and big
    data.</p>
</li>
<li>
<p>This section focused on establishing a case for the importance of
    the modeling performed by current ML techniques. In a sense, this
    can be considered the <em>what</em> -- what exactly FL is trying to do.</p>
</li>
<li>
<p>Next, we will focus on the <em>where</em> in terms of the desired setting
    for numerous ML applications.</p>
</li>
</ul>
<p>Distributed Learning and Scalability</p>
<ul>
<li>
<p>In this section, we introduce the distributed computing setting and
    discuss the intersection of this setting with ML approaches to fully
    establish the support for why FL is necessary.</p>
</li>
<li>
<p>The goal of the section is for the user to understand both the
    benefits and limitations imposed by the distributed computing
    setting, in order to understand how FL addresses some of these
    limitations.</p>
</li>
</ul>
<p>Distributed computing</p>
<ul>
<li>
<p>The past several years have shown a large but predictable rise in
    the development of new approaches and the conversion of existing
    server infrastructure within the lens of distributed computing.</p>
</li>
<li>
<p>To generalize further, distributed approaches themselves have
    shifted more and more from research implementations to extensive use
    in production settings; one significant example of this phenomenon
    is the usage of cloud computing platforms such as <strong>AWS</strong>
    from Amazon, <strong>Google Cloud Platform</strong> (<strong>GCP</strong>) from Google, and
    <strong>Azure</strong> from Microsoft. It turns out that the flexibility of
    on-demand resources allows for cost-saving and efficiency in
    numerous applications that would, otherwise, be bottlenecked by
    on-premise servers and computational power.</p>
</li>
<li>
<p>While a parallel cannot exactly be drawn between cloud computing and
    the concept of distributed computing, the key benefits stemming from
    the distributed nature are similar.</p>
</li>
<li>
<p>At a high level, distributed computing involves spreading the work
    necessary for some computational task over a number of computational
    agents in a way that allows each to act near-autonomously.</p>
</li>
<li>
<p>The following figure shows the difference between centralized and
    distributed approaches in the high-level context of answering
    questions:</p>
</li>
</ul>
<p>Figure 2.2 -- Centralized versus distributed question answering</p>
<ul>
<li>
<p>In this simple example, the centralized approach involves processing
    the input questions sequentially, whereas the distributed approach
    is able to process each question at the same time. It should be
    clear that the parallel approach trades off computational resource
    usage for increased answering speed.</p>
</li>
<li>
<p>The question, then, is whether this trade-off is beneficial for
    real-world applications.</p>
</li>
</ul>
<p><strong>A Real-world example</strong></p>
<ul>
<li>
<p>To understand the practical benefits of distributed computing
    approaches, let's analyze an example business problem through a
    traditional and a distributed computing lens.</p>
</li>
<li>
<p>Consider an e-commerce business that is trying to host its website
    using on-premise servers.</p>
</li>
<li>
<p>The traditional way to do this would be to perform enough analysis
    on the business side to determine the expected volume of traffic at
    some future time and invest in one or a couple of server machines
    large enough to handle that calculated volume.</p>
</li>
<li>
<p>Several cases immediately lend themselves to showing the flaws of
    such an approach.</p>
</li>
<li>
<p>Consider a scenario where usage of the websites greatly exceeds the
    initial projections.</p>
</li>
<li>
<p>A fixed number of servers means that all upgrades must be hardware
    upgrades, resulting in old hardware that had to be purchased and is
    no longer used.</p>
</li>
<li>
<p>Going further, there are no guarantees that the now-increased usage
    will stay fixed. Further increases in usage will result in more
    scaling-up costs, while decreases in usage will lead to wasted
    resources (maintaining large servers when smaller machines would be
    sufficient).</p>
</li>
<li>
<p>A key point is that the integration of additional servers is
    non-trivial due to the single-machine approach used to manage
    hosting.</p>
</li>
<li>
<p>Additionally, we have to consider the hardware limitations of
    handling large numbers of requests in parallel with one or a few
    machines.</p>
</li>
<li>
<p>The ability to handle requests in parallel is limited for each
    machine -- significant volumes of traffic would be almost guaranteed
    to eventually be bottlenecked regardless of the power available to
    each server.</p>
</li>
<li>
<p>In comparison, consider the distributed computing-based solution for
    this problem.</p>
</li>
<li>
<p>Based on the initial business projections, a number of smaller
    server machines are purchased and each is set up to handle some
    fixed volume of traffic.</p>
</li>
<li>
<p>If the scenario of incoming traffic exceeding projects arises, no
    modification to the existing machines is necessary; instead, more
    similarly-sized servers can be purchased and configured to handle
    their designated volume of new traffic.</p>
</li>
<li>
<p>If the incoming traffic decreases, the equivalent number of servers
    can be shut down or shifted to handle other tasks. This means that
    the same hardware can be used for variable volumes of traffic.</p>
</li>
<li>
<p>This ability to scale quickly to handle the necessary computational
    task at any moment is precisely due to how distributed computing
    approaches allow for computational agents to seamlessly start and
    stop working on said task.</p>
</li>
<li>
<p>In addition, the use of many smaller machines in parallel, versus
    using fewer larger machines, means that the number of requests that
    can be handled at the same time is notably higher. It is clear that
    a distributed computing approach, in this case, lends itself to
    cost-saving and flexibility that cannot be matched with more
    traditional methods.</p>
</li>
</ul>
<p><strong>Distributed Computing - The benefits</strong></p>
<ul>
<li>
<p>In general, distributed computing approaches offer three main
    benefits for any computational task -- scalability, throughput, and
    resilience.</p>
</li>
<li>
<p>In the previous case of web hosting, scalability referred to the
    ability to scale the number of servers deployed based on the amount
    of incoming traffic, whereas throughput refers to the ability to
    reduce request processing latency through the inherent parallelism
    of smaller servers.</p>
</li>
<li>
<p>In this example, resilience could refer to the ability of other
    deployed servers to take on the load from a server that stops
    working, allowing the hosting to continue relatively unfazed.</p>
</li>
<li>
<p>Distributed computing often finds uses when working with large
    stores of data, especially when attempting to perform analyses on
    the data using a single machine would be computationally infeasible
    or otherwise undesirable.</p>
</li>
<li>
<p>In these cases, scalability allows for the deployment of a variable
    number of agents based on factors such as the desired runtime and
    amount of data at any given time, whereas the ability of each agent
    to autonomously work on processing a subset of the data in parallel
    allows for processing throughput that would be impossible for a
    single high-power machine to achieve.</p>
</li>
<li>
<p>It turns out that this lack of reliance on cutting-edge hardware
    leads to further cost savings, as hardware price-to-performance
    ratios are often not linear.</p>
</li>
<li>
<p>While the development of parallelized software to operate in a
    distributed computing setting is non-trivial, hopefully, it is clear
    that many practical computational tasks greatly benefit from the
    scalability and throughput achieved by such approaches.</p>
</li>
</ul>
<p>Distributed ML</p>
<ul>
<li>
<p>When thinking about the types of computational tasks that have
    proven to be valuable in practical applications and that might be
    directly benefited from increased scalability and throughput, it is
    clear that the rapidly growing field of ML is near the top.</p>
</li>
<li>
<p>In fact, we can frame ML tasks as a specific example of the
    aforementioned tasks of analyzing large stores of data, placing
    emphasis on the data being processed and the nature of the analysis
    being performed.</p>
</li>
<li>
<p>The joint growth of cheap computational power (for example, smart
    devices) and the proven benefits of data analysis and modeling have
    led to companies with both the storage of excessive amounts of data
    and the desire to extract meaningful insights and predictions from
    said data.</p>
</li>
<li>
<p>The second part is exactly what ML is geared to solve, and large
    amounts of work have already been completed to do so in various
    domains.</p>
</li>
<li>
<p>However, like other computational tasks, performing ML on large
    stores of data often leads to a time-computational power trade-off
    in which more powerful machines are needed to perform such tasks in
    reasonable amounts of time.</p>
</li>
<li>
<p>As ML algorithms become more computationally and memory-intensive,
    such as recent state-of-the-art deep learning models with billions
    of parameters, hardware bottlenecks make increasing the
    computational power infeasible.</p>
</li>
<li>
<p>As a result, current ML tasks must apply distributed computing
    approaches to stay cutting-edge while producing results in usable
    timeframes.</p>
</li>
</ul>
<p>ML at the Edge</p>
<ul>
<li>
<p>Although the prevalence of deep learning described earlier, besides
    the paradigm shift from big data to collective intelligence gives
    enough motivation for distributed ML, its physical foundation came
    from the recent development of <strong>edge computing</strong>.</p>
</li>
<li>
<p>The <em>edge</em> represents the close proximity around deployed solutions;
    it follows that edge computing refers to processing data at or near
    the location of the data source.</p>
</li>
<li>
<p>Extending the concept of computation to ML leads to the idea
    of <strong>edge AI</strong>, where models are integrated directly into edge
    devices.</p>
</li>
<li>
<p>A few popular examples would be Amazon Alexa, where edge AI takes
    care of speech recognition, and self-driving cars that collect
    real-world data and incrementally improve with edge AI.</p>
</li>
<li>
<p>The most ubiquitous example is the smartphone -- some potential uses
    are the recommendation of content to the user, searches with voice
    assistance and auto-complete, auto-sorting of pictures into an album
    and gallery search, and more.</p>
</li>
<li>
<p>To capitalize on this potential, smartphone manufacturers have
    already begun integrating ML-focused processor components into the
    chips they integrate with their newest phones, such as the <em>Neural
    Processing Unit</em> from <em>Samsung</em> and the <em>Tensor Processing Unit</em> on
    the <em>Google Tensor chip</em>.</p>
</li>
<li>
<p>Google has also worked to develop ML-focused APIs for Android
    applications through their <em>Android ML Kit SDK</em>.</p>
</li>
<li>
<p>From this, it should be clear that ML applications are shifting
    toward the edge computing paradigm.</p>
</li>
<li>
<p>Let's say that smartphones need to use a deep learning model for
    word recommendation. This is so that when you type words on your
    phone, it gives you suggestions for the next word, with the goal
    being to save you some time.</p>
</li>
<li>
<p>In the scheme of a centralized computing process, the central server
    is the only component that has access to this text prediction model
    and none of the phones have the model stored locally.</p>
</li>
<li>
<p>The central server handles all of the requests sent from the phones
    to return word recommendations.</p>
</li>
<li>
<p>As you type, your phone has to send what has been typed along with
    some personal information about you, all the way to the central
    server. The server receives this information, makes a prediction
    using the deep learning model, and then sends the result back to the
    phone.</p>
</li>
<li>
<p>The following figure reflects this scenario:</p>
</li>
</ul>
<p><img alt="Figure 2.3 -- Centralized inference scenario
" src="../images/media/image78.jpg" />{width="6.268055555555556in"
height="2.5076388888888888in"}</p>
<p>Figure 2.3 -- Centralized inference scenario</p>
<ul>
<li>
<p>There are a few problems that become apparent when you look at this
    scenario.</p>
</li>
<li>
<p>First, even a half to one second of latency makes the recommendation
    slower than typing everything yourself, making the system useless.</p>
</li>
<li>
<p>Furthermore, if there is no internet connection, the recommendation
    simply does not work.</p>
</li>
<li>
<p>Another restriction of this scheme is the need for the central
    server to process all of these requests. Imagine how many
    smartphones are being used in the world, and you will realize a lack
    of feasibility due to the extreme scale of this solution.</p>
</li>
<li>
<p>Now, let's look at the same problem from the edge computing
    perspective.</p>
</li>
<li>
<p>What if the smartphones themselves contain the deep learning model?</p>
</li>
<li>
<p>The central server is only in charge of managing the latest trained
    model and communicating this model with each phone.</p>
</li>
<li>
<p>Now, whenever you start typing, your phone can use the received
    model locally to make recommendations from what you typed. The
    following figure reflects this scenario:</p>
</li>
</ul>
<p><img alt="Figure 2.4 -- Edge inference scenario
" src="../images/media/image70.jpg" />{width="6.268055555555556in"
height="2.704861111111111in"}</p>
<p>Figure 2.4 -- Edge inference scenario</p>
<ul>
<li>
<p>This removes both the latency problem and prevents the need to
    handle the incoming inference requests at a central location.</p>
</li>
<li>
<p>In addition, the phones no longer have to maintain a connection with
    the server to make a recommendation.</p>
</li>
<li>
<p>Each phone is in charge of fulfilling requests from its user.</p>
</li>
<li>
<p>This is the core benefit of edge computing: <em>we have moved the
    computing load from the central server to the edge devices/servers</em>.</p>
</li>
</ul>
<p>Training at the Edge</p>
<ul>
<li>
<p>The distinction between centralized and decentralized computing can
    be extended to the concept of model training.</p>
</li>
<li>
<p>Let's stick to the smartphone example but think about how we would
    train the predictive model instead.</p>
</li>
<li>
<p>First, in the centralized ML process, all of the data used to train
    the recommendation model must be collected from the users' devices
    and stored on the central server.</p>
</li>
<li>
<p>Then, the collected data is used to train a model, which is
    eventually sent to all the phones.</p>
</li>
<li>
<p>This means that the central server still has to be able to handle
    the large volume of user data coming in and store it in an efficient
    way to be able to train the model.</p>
</li>
<li>
<p>This design leads to the problems found in the centralized computing
    approach: as the number of phones connected to the server increases,
    the server's ability to work with the incoming data needs to scale
    in order to maintain the training process. In addition, since the
    data needs to be transmitted and stored centrally in this approach,
    there is always the possibility of the interception of transmissions
    or even attacks on the stored data.</p>
</li>
<li>
<p>There are several cases where data confidentiality and privacy are
    required or strongly desired; for example, applications in the
    financial and medical industries. </p>
</li>
<li>
<p><em>Centralized model training thus limits use cases, and an
    alternative way to work with data directly on edge devices is
    required</em>. This exact setting is the motivation for FL.</p>
</li>
</ul>
<p>FL - The technical bits</p>
<ul>
<li>
<p>This section focuses on providing a high-level technical
    understanding of how FL actually slots in as a solution to the
    problem setting described in the previous section.</p>
</li>
<li>
<p>The goal of this section is for you to understand how FL fits as a
    solution, and to provide a conceptual basis that will be filled in
    by the subsequent sections.</p>
</li>
</ul>
<p>FL Definition</p>
<ul>
<li>
<p><em>Federated learning is a method to synthesize global models from
    local models trained on the edge</em>.</p>
</li>
<li>
<p>FL was first developed by Google in 2016 for their Gboard
    application, which incorporates the context of an Android user's
    typing history to suggest corrections and propose candidates for
    subsequent words.</p>
</li>
<li>
<p>Indeed, this is the exact word recommendation problem discussed in
    the <em>Edge inference</em> and <em>Edge training</em> sections.</p>
</li>
<li>
<p>The solution that Google produced was a decentralized training
    approach where an iterative process would compute model training
    updates at the edge, aggregating these updates to produce the global
    update to be applied to the model.</p>
</li>
<li>
<p>This core concept of aggregating model updates was key in allowing
    for a single, performant model to be produced from edge training.</p>
</li>
<li>
<p>Let's break this concept down further.</p>
</li>
<li>
<p>The desired model is distributed across the edge and is trained on
    data collected locally at the edge.</p>
</li>
<li>
<p>Of course, we can expect that a model trained on one specific data
    source is not going to be representative of the entire dataset.</p>
</li>
<li>
<p>As a result, we dub such models trained with limited data <strong>local
    models</strong>. One immediate benefit of this approach is the enabling of
    ML on data that would otherwise not be collected in the centralized
    case, due to issues with privacy and efficiency.</p>
</li>
<li>
<p>Aggregation, the key theoretical step of FL, allows for our desired
    single <strong>global model</strong> to be created from the set of local models
    produced at some iteration.</p>
</li>
<li>
<p>The most well-known aggregation algorithm, popular for its
    simplicity and surprising performance, is called <strong>federated
    averaging</strong> (<strong>FedAvg</strong>).</p>
</li>
<li>
<p>FedAvg is performed on a set of local models by computing the
    <strong><em>parameter-wise arithmetic mean</em></strong> across the models, producing an
    aggregate model.</p>
</li>
<li>
<p>It is important to understand that performing aggregation <strong>once</strong>
    is <strong>not enough</strong> to produce a good global aggregate model; instead,
    it is the <strong>iterative process of locally training</strong> <strong>the previous
    global model</strong> and <strong>aggregating the produced local models into a
    new global model</strong> that allows for global training progress to be
    made.</p>
</li>
</ul>
<p>The FL process</p>
<p>To better understand FL from an iterative process perspective, we break
it down into the core constituent steps of a single iteration,
or <em>round</em>.</p>
<p>The steps for a round can be described as follows:</p>
<ol>
<li>
<p>The aggregate global model parameters are sent to each user's
    device.</p>
</li>
<li>
<p>The received ML models located on the user devices are trained with
    local data.</p>
</li>
<li>
<p>After a certain amount of training, the local model parameters are
    sent to the central server.</p>
</li>
<li>
<p>The central server aggregates the local models by applying an
    aggregation function, producing a new aggregate global model.</p>
</li>
</ol>
<p>These steps are depicted in <em>Figure 2.5</em>:</p>
<p><img alt="Figure 2.5 -- FL steps
" src="../images/media/image77.jpg" />{width="6.268055555555556in"
height="4.667361111111111in"}</p>
<p>Figure 2.5 -- FL steps</p>
<ul>
<li>
<p>The flow from <em>steps 1 to 4</em> constitutes a single round of FL.</p>
</li>
<li>
<p>The next round begins as the user servers/devices receive the newly
    created aggregate model and start training on the local data.</p>
</li>
<li>
<p>Let's revisit Google's word recommendation for Gboard.</p>
</li>
<li>
<p>At some point in time, each phone stores a sufficient amount of its
    user's typing data.</p>
</li>
<li>
<p>The edge training process can create a local model from it, and the
    parameters will be sent to the central server.</p>
</li>
<li>
<p>After receiving parameters from <strong><em>a certain number of phones</em></strong>,
    the server aggregates them to create a global model and sends it to
    the phones.</p>
</li>
<li>
<p>This way, every phone connected to the server receives a model that
    reflects local data in all of the phones without ever transmitting
    the data from them.</p>
</li>
<li>
<p>In turn, each phone retrains the model when another batch of
    sufficient data is collected, sends the model to the server, and
    receives a new global model.</p>
</li>
<li>
<p>This cycle repeats itself over and over according to the
    configuration of the FL system, resulting in the continuous
    monitoring and updating of the global model.</p>
</li>
<li>
<p>Note that the <strong><em>user data never leaves the edge</em></strong>, only the model
    parameters; nor is there a need to put all the data in a central
    server to generate a global model, allowing for data minimalism.</p>
</li>
<li>
<p>Moreover, model bias can be mitigated with FL methods, as discussed.</p>
</li>
<li>
<p>That is why FL can be regarded as a solution to the three issues of
    big data, which were introduced earlier (Triple A).</p>
</li>
</ul>
<p><strong>Transfer learning</strong></p>
<ul>
<li>
<p>FL is closely related to an ML concept called <strong>transfer
    learning</strong> (<strong>TL</strong>).</p>
</li>
<li>
<p>TL allows us to use large deep learning models that have been
    trained by researchers using plentiful compute power and resources
    on very generalized datasets.</p>
</li>
<li>
<p>These models can be applied to more specific problems.</p>
</li>
<li>
<p>For example, we can take an object detection model trained to locate
    and name specific objects in images and retrain it on a limited
    dataset containing specific objects we are interested in, which were
    not included in the original data.</p>
</li>
<li>
<p>If you were to take the original data, add to it the data of those
    objects of our interest, and then train a model from scratch, a lot
    of computational time and power would be required.</p>
</li>
<li>
<p>With TL, you can quicken the process by leveraging a key fact about
    those existing large, generalized models.</p>
</li>
<li>
<p>There is a tendency for the intermediate layers of large DNNs to be
    excellent at extracting features, used by the following layers for
    the specific ML task.</p>
</li>
<li>
<p>We can maintain its learned ability to extract features by
    preserving the parameters in those layers.</p>
</li>
<li>
<p>In other words, parameters in certain layers of existing pre-trained
    models can be <strong>preserved</strong> and used to detect new objects -- we do
    not need to reinvent the wheel.</p>
</li>
<li>
<p>This technique is called <strong>parameter freezing</strong>.</p>
</li>
<li>
<p>In FL, model training often takes place in local devices/servers
    with limited computational power.</p>
</li>
<li>
<p>One example using the Gboard scenario is performing parameter
    freezing on a pre trained word embedding layer to allow training to
    focus on task-specific information, leveraging prior training of the
    embeddings to greatly reduce the trainable parameter count.</p>
</li>
<li>
<p>Taking this concept further, the intersection of FL and TL is
    called <strong>federated transfer learning</strong> (<strong>FTL</strong>).</p>
</li>
<li>
<p>FTL allows for the FL approach to be applied in cases where the
    local datasets differ in structure by performing FL on a shared
    subset of the model that can later be extended for specific tasks.</p>
</li>
<li>
<p>For example, a sentiment analysis model and a text summarization
    model could both share a sentence encoding component, which can be
    trained using FL and used for both tasks.</p>
</li>
<li>
<p>TL (and, by extension, FTL) are key concepts that allow for training
    efficiency and incremental improvement to be realized in FL.</p>
</li>
</ul>
<p><strong>Personalization</strong></p>
<ul>
<li>
<p>When edge devices are dealing with data that is not <strong>independent
    and identically distributed</strong> (<strong>IID</strong>), each device can customize
    the global model.</p>
</li>
<li>
<p>This is an idea called <strong>personalization</strong>, which can be considered
    as fine-tuning the global model with local data, or the strategic
    use of bias in the data.</p>
</li>
<li>
<p>For example, consider a shopping mall chain that operates in two
    areas with distinct local demographics (that is, the chain deals
    with non-IID data).</p>
</li>
<li>
<p>If the chain seeks tenant recommendations for both locations using
    FL, each of the locations can be better served with personalized
    models than a single global model, helping attract local customers.
    Since the personalized model is fine-tuned or <em>biased</em> with local
    data, we can expect that its performance on general data would not
    be as good as that of the global model.</p>
</li>
<li>
<p>On the other hand, we can also expect that the personalized model
    performs better than the global model on the local data for which
    the model is personalized.</p>
</li>
<li>
<p>There is a trade-off between user-specific performance and
    generalizability, and the power of an FL system comes from its
    flexibility to balance them according to the requirements.</p>
</li>
</ul>
<p><strong>Horizontal and Vertical FL</strong></p>
<ul>
<li>
<p>There are two types of FL: <strong>horizontal</strong> or <strong>homogeneous
    FL</strong> and <strong>vertical</strong> or <strong>heterogeneous FL</strong>.</p>
</li>
<li>
<p>Horizontal FL, also called <strong>sample-based FL</strong>, is applicable when
    all local datasets connected with the aggregator server have the
    same features but contain different samples.</p>
</li>
<li>
<p>The Gboard application discussed earlier is a good example of
    horizontal FL in the form of <strong>cross-device FL</strong>, that is, local
    training taking place in edge devices.</p>
</li>
<li>
<p>The datasets in all Android phones have identical formats but unique
    contents that reflect their user's typing history.</p>
</li>
<li>
<p>On the other hand, vertical FL, or <strong>feature-based FL</strong>, is a more
    advanced technology that allows parties holding different features
    for the same samples to cooperatively generate a global model.</p>
</li>
<li>
<p>For example, a bank and an e-commerce company might both store the
    data of residents in a city but their features would differ: the
    former knows the credit and expenditure patterns of the citizens,
    the latter their shopping behavior.</p>
</li>
<li>
<p>Both of them can benefit by sharing valuable insights without
    sharing customer data.</p>
</li>
<li>
<p>First, the bank and e-commerce company can identify their common
    users with a technique called <strong>private set intersection</strong> (<strong>PSI</strong>)
    while preserving data privacy
    using <strong>Rivest-Shamir-Adleman</strong> (<strong>RSA</strong>) encryption.</p>
</li>
<li>
<p>Next, each party trains a preliminary model with local data
    containing unique features.</p>
</li>
<li>
<p>Those models are then aggregated to construct a global model.</p>
</li>
<li>
<p>Usually, vertical FL involves multiple data silos, and when that is
    the case, it is also called <strong>cross-silo FL</strong>.</p>
</li>
<li>
<p>In China, <strong>federated Ai ecosystem</strong> (<strong>FATE</strong>) is well known for
    its seminal demonstration of vertical FL involving WeBank. If you
    are interested in further conceptual details of FL, there is a very
    illustrative and well-written report by Cloudera Fast Forward Labs,
    at https://federated.fastforwardlabs.com/.</p>
</li>
<li>
<p>The information on FL contained in this section should be sufficient
    to understand the following parts, which examine, in further depth,
    some of the key concepts introduced here.</p>
</li>
<li>
<p>The final section aims to cover some of the auxiliary concepts
    focused on the practical application of FL.</p>
</li>
</ul>
<p>System Considerations for FL</p>
<ul>
<li>
<p>This section mainly focuses on the multi-party computation aspects
    of FL, including theoretical security measures and full
    decentralization approaches.</p>
</li>
<li>
<p>The goal of this section is for you to be aware of some of the more
    practical considerations that should be taken into account for
    practical FL applications.</p>
</li>
</ul>
<p>Security Considerations for FL</p>
<ul>
<li>
<p>Despite the nascency of the technology, experimental usage of FL has
    emerged in a few sectors.</p>
</li>
<li>
<p>Specifically, <strong>anti-money laundering</strong> (<strong>AML</strong>) in the financial
    industry and drug discovery and diagnosis in the medical industry
    have seen promising results, as proofs of concepts in those fields
    have been successfully conducted by companies such as Consilient and
    Owkin.</p>
</li>
<li>
<p>In AML use cases, banks can cooperate with one another to identify
    fraudulent transactions efficiently without sharing their account
    data; and hospitals can keep their patient data to themselves while
    improving ML models for detecting health issues.</p>
</li>
<li>
<p>These solutions exploit the power of relatively simple horizontal
    cross-silo FL, as explained in the <em>Understanding FL</em> section, and
    its application is spreading to other areas.</p>
</li>
<li>
<p>For example, Edgify is a UK-based company contributing to the
    automation of cashiers at retail stores in collaboration with Intel
    and Hewlett Packard.</p>
</li>
<li>
<p>In Munich, Germany, another UK-based company, Fetch.ai, is
    developing a smart city infrastructure with their FL-based
    technology. It is clear that the practical application of FL is
    rapidly growing.</p>
</li>
<li>
<p>Although FL can circumvent the concern over data privacy thanks to
    its privacy-by-design (model parameters do not expose privacy) and
    data minimalist (data is not collected in the central server)
    approach, there are potential obstructions against its
    implementation; one such example is <em>mistrust</em> among the
    participants of an FL project.</p>
</li>
<li>
<p>Consider a situation where <em>Bank A</em> and <em>Bank B</em> agree to use FL for
    developing a collaborative AML solution.</p>
</li>
<li>
<p>They decide on the common model architecture so that each can train
    a local model with their own data and aggregate the results to
    create a global model to be used by both.</p>
</li>
<li>
<p>Naïve implementations of FL might allow for one bank to reconstruct
    the local model from the other bank, using their local model and the
    aggregate model.</p>
</li>
<li>
<p>From this, the bank might be able to extract key information on the
    data used to train the other bank's model.</p>
</li>
<li>
<p>As a result, there might be a dispute regarding which party should
    host the server to aggregate the local models.</p>
</li>
<li>
<p>A possible solution is having a third party host the server and take
    responsibility for model aggregation.</p>
</li>
<li>
<p>Yet, how would <em>Bank A</em> know that the third party is not colluding
    with <em>Bank B</em>, and vice versa?</p>
</li>
<li>
<p>Going further, the integration of an FL system into a
    security-focused domain leads to new concerns regarding the security
    and stability of each system component.</p>
</li>
<li>
<p>Known security issues tied to different FL system approaches might
    incur an additional potential weakness to adversarial attacks that
    outweighs the benefits of the approach.</p>
</li>
<li>
<p>There are several security measures to allow FL collaboration
    without forcing the participants to trust one another.</p>
</li>
<li>
<p>With a statistical method called <strong>differential privacy</strong> (<strong>DP</strong>),
    each participant can add random noise to their local model
    parameters to prevent the ability to glean information on the
    training data distribution or specific elements from the transmitted
    parameters.</p>
</li>
<li>
<p>By sampling the random noise from a symmetric distribution with zero
    mean and relatively low variance (for example, Gaussian, Laplace),
    the random differences added to the local models are expected to
    cancel out when aggregation is performed.</p>
</li>
<li>
<p>As a result, the global model is expected to be very similar to what
    would have been generated without DP.</p>
</li>
<li>
<p>However, there is a critical limitation to this approach; for the
    sum of the added random noise to converge to zero, a sufficient
    number of parties must participate in the coalition.</p>
</li>
<li>
<p>This might not be the case for projects involving only a few banks
    or hospitals, and using DP in such cases would harm the global
    model's integrity.</p>
</li>
<li>
<p>Some additional measures would be necessary, for example, each
    participant sending multiple copies of their local model to increase
    the number of models so that the noise will be offset.</p>
</li>
<li>
<p>Another possibility in certain fully-decentralized FL systems
    is <strong>secure multi-party computation</strong> (<strong>MPC</strong>).</p>
</li>
<li>
<p>MPC-based aggregation allows agents to communicate among themselves
    and compute the aggregate model without involving a trusted
    third-party server, maintaining model parameter privacy.</p>
</li>
<li>
<p>How could the participants secure the system from outside attacks? </p>
</li>
<li>
<p><strong>Homomorphic encryption</strong> (<strong>HE</strong>), which preserves the effects of
    addition and multiplication on data across encryption, allows the
    local models to be aggregated into the global model in an encrypted
    form.</p>
</li>
<li>
<p>This precludes the exposure of model parameters to outsiders who do
    not possess the key for decryption.</p>
</li>
<li>
<p>Yet, HE's effectiveness in securing the communication between
    the participants comes with a prohibitively high computational cost:
    processing the operation on data with the HE algorithm can take
    hundreds of trillions of times longer than otherwise!</p>
</li>
<li>
<p>A solution to mitigate this challenge is the use of partial HE,
    which is compatible with only one of the additive or multiplicative
    operations across encryption; therefore it is computationally much
    lighter than the fully homomorphic counterpart.</p>
</li>
<li>
<p>Using this scheme, each participant in a coalition can encrypt and
    send their local model to the aggregator, which then sums up all
    local models and sends the aggregated model back to the
    participants, who, in turn, decrypt the model and divide its
    parameters by the number of participants to receive the global
    model.</p>
</li>
<li>
<p>Both HE and DP are essential technology for the practical
    application of FL.</p>
</li>
<li>
<p>Those interested in the implementation of FL in real-world scenarios
    can learn a great deal from <em>Federated AI for Real-World Business
    Scenarios</em> written by IBM Research Fellow Dinesh C. Verma.</p>
</li>
</ul>
<p>Decentralized FL and Blockchain</p>
<ul>
<li>
<p>The architecture of FL discussed so far is based on client-server
    networks, that is, edge devices exchanging models with a central
    aggregator server.</p>
</li>
<li>
<p>Due to the issues surrounding trust between the participants of FL
    coalitions discussed earlier; however, building a system with an
    aggregator as a separate and central entity can be problematic.</p>
</li>
<li>
<p>It can be difficult for the host of an aggregator to be impartial
    and unbiased toward their own data.</p>
</li>
<li>
<p>Also, having a central server inevitably leads to a single point of
    failure in the FL system, which results in low resilience.</p>
</li>
<li>
<p>Furthermore, if the aggregator is set up in a cloud server, the
    implementation of such an FL system would require a skilled DevOps
    engineer, who might be difficult to find and expensive to hire.</p>
</li>
<li>
<p>Given these concerns, Kiyoshi Nakayama co-authored an article about
    the first-ever experimentation of a fully decentralized FL system
    using blockchain technology
    (<a href="http://www.kiyoshi-nakayama.com/publications/BAFFLE.pdf">[http://www.kiyoshi-nakayama.com/publications/BAFFLE.pdf]{.underline}</a>).</p>
</li>
<li>
<p>Leveraging <strong>smart contracts</strong> to coordinate model updates and
    aggregation, a private Ethereum network was constructed to perform
    FL in a serverless manner.</p>
</li>
<li>
<p>The results of the experiment showed that a <strong><em>peer-to-peer,
    decentralized FL can be much more efficient and scalable than an
    aggregator-based, centralized FL</em></strong>.</p>
</li>
<li>
<p>The superiority of decentralized architecture was confirmed in a
    more recent experiment conducted by Hewlett Packard and German
    research institutes who gave a unique name to decentralized FL with
    blockchain technology: <strong>swarm learning</strong>.</p>
</li>
<li>
<p>While research and development in the field of FL are shifting to a
    decentralized model, the rest of this book assumes centralized
    architecture with an aggregator server. There are two reasons for
    this design. First, blockchain is still a nascent technology that AI
    and ML researchers are not necessarily familiar with. Incorporating
    a peer-to-peer communication scheme can overcomplicate the subject
    matter. And second, the logic of FL itself is independent of the
    network architecture, and there is no problem with the centralized
    model to illustrate how FL works.</p>
</li>
</ul>
<p>Summary</p>
<ul>
<li>
<p>Here, we covered the two key developments that have resulted from
    the recent growth in accessible computational power at all levels.</p>
</li>
<li>
<p>First, we looked at the importance of models and how this has
    enabled ML to grow considerably in practical usage, with increases
    in computational power allowing stronger models that surpass
    manually created white-box systems to continuously be produced.</p>
</li>
<li>
<p>We called this the <em>what</em> of FL -- ML is what we are trying to
    perform using FL.</p>
</li>
<li>
<p>Then, we took a step back to look at how edge devices are reaching a
    stage where complex computations can be performed within reasonable
    timeframes for real-world applications, such as the text
    recommendation models on our phones.</p>
</li>
<li>
<p>We called this the <em>where</em> of FL -- the setting where we want to
    perform ML.</p>
</li>
<li>
<p>From the what and the where, we get the intersection of these two
    developments -- the usage of ML models directly on edge devices.</p>
</li>
<li>
<p>Remember that the standard central training approach for ML models
    greatly suffers from the need to centrally collect all of the data
    in the edge ML case, as this prevents applications requiring
    efficient communication or data privacy from being possible.</p>
</li>
<li>
<p>We showed that <em>FL</em> directly addresses this problem by performing
    all training at the edge to produce <em>local models</em>, at the same
    location as the requisite data stores. <em>Aggregation</em> algorithms take
    these local models and produce a <em>global model</em>. By iteratively
    switching between local training and aggregation,</p>
</li>
<li>
<p>FL allows for the creation of a model that has effectively been
    trained across all data stores without ever needing to centrally
    collect the data.</p>
</li>
<li>
<p>We concluded the part by stepping outside the theory behind
    effective aggregation, looking at system and architecture design
    considerations regarding aspects such as model privacy and full
    decentralization.</p>
</li>
<li>
<p>After reading, it should be clear that the current state of ML, edge
    computing, and fledgling growth in practical FL applications makes
    it clear that FL is poised for serious growth in the near future.</p>
</li>
<li>
<p>In the next part, we will examine the implementation of FL from a
    system-level perspective.</p>
</li>
</ul>












                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      &copy; 2024 <a href="https://spanda.io"  target="_blank" rel="noopener">Spanda.io</a>

    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://ranga-rangarajan.github.io/spanda-bootcamp/" target="_blank" rel="noopener" title="ranga-rangarajan.github.io" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.sections", "toc.integrate", "navigation.top", "search.suggest", "search.highlight", "content.tabs.link", "content.code.annotation", "content.code.copy"], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.caa56a14.min.js"></script>
      
    
  </body>
</html>